import cv2
import numpy as np

# ? ููุณ ุงูุฏุงูุฉ ูู ููุฑุณ ุงููุจุชุฏุฆูู


def resize(image, width=None, height=None, show=False):
    """
        Arguments:
            image {np.array} -- ุงูุตูุฑุฉ ุงููุฑุงุฏ ุชุบููุฑ ุญุฌููุง

        Keyword Arguments:
            width {[int]} -- ุงูุนุฑุถ ุงูุฌุฏูุฏ ููุตูุฑุฉ ุจุนุฏ ุชุบููุฑ ุญุฌููุง
            height {[int]} -- ุงูุงุฑุชูุงุน ุงูุฌุฏูุฏ ููุตูุฑุฉ ุจุนุฏ ุชุบููุฑ ุญุฌููุง
            show {bool} -- ุฅุธูุงุฑ ุงูุตูุฑุฉ ุงูุชู ุชู ุชุบููุฑ ุญุฌููุง ุฃู ูุง

        Returns:
            [np.array] -- ุงูุตูุฑุฉ ุงูุชู ุชู ุชุบููุฑ ุญุฌููุง
    """
    if width is None and height is None:
        return image

    if width is None:
        r = height / image.shape[0]
        width = int(r * image.shape[1])
    elif height is None:
        r = width / image.shape[1]
        height = int(r * image.shape[0])

    resized = cv2.resize(image, (width, height), interpolation=cv2.INTER_AREA)

    if show:
        cv2.imshow('Image Resized By {0:.2f}'.format(r), resized)
        cv2.waitKey(0)

    return resized


def draw_corners(img, points):
    """
    ุฏุงูุฉ ุจุณูุทุฉ ูุฑุณู ุงูููุท ุงููุนุทุงุฉ ุนูู ุงูุตูุฑุฉ ุงููุนุทุงุฉ
    """
    # ? ุชู ุฑุณู ุงูููุท ุจุชูู ุงูุงููุงู ุงููุญุฏุฏุฉ ุญุชู ูุชู
    # ? ุงูุชูุฑูู ุจูู ุงูุฃุฑูุงู ุงูุงุฑุจุนุฉ ุงููุฑุชุจุฉ ูุงูุบูุฑ ูุฑุชุจุฉ
    if len(points) == 4:
        p1, p2, p3, p4 = points
        cv2.circle(img, tuple(p1), 6, (0, 0, 255), -1)
        cv2.circle(img, tuple(p2), 6, (0, 255, 0), -1)
        cv2.circle(img, tuple(p3), 6, (255, 0, 0), -1)
        cv2.circle(img, tuple(p4), 6, (0, 255, 255), -1)

    else:
        from random import sample
        for p in points:
            random_color = tuple(sample(range(0, 255), 3))
            cv2.circle(img, tuple(p), 6, random_color, -1)

    cv2.imshow("image", img)
    cv2.waitKey(0)


def get_corner_points(contour):
    """
        cv2.arclength(contour, closed)
        ------------
            ุงูุฏุงูุฉ ุจุชุญุณุจ ุงููุญูุท 
            closed: [True OR False] ูู ุงูุดูู ูุบูู 

        cv2.approxPolyDP(contour, epsilon, closed)
        --------------------------------------------
            contour ุจุชุฑุฌุน ุงูู ุนุฏุฏ ูู ุงูููุท ุงููู ูููู ุชูุซู ุงุฑูุงู ุงู 
            ุจูุญูุซ ููุง ุจูุญุณุจ ุงูุฃุฑูุงู ุจูุฌูุจ ุงููุญูุท ุงููู ุจุชูููู ุงูููุท ุฏู 
            contour ูุจููุงุฑูู ุจุงููุญูุท ุงูุงุตูู ุจุชุงุน ุงู 
            contour ุนุงุฏุฉ ูุณุจุฉ ุงูุฎุทุง ุฏู ุนุจุงุฑุฉ ุนู (%1 : %5) ูู ุงููุญูุท ุงูุงุตูู ุจุชุงุน ุงู 

            epsilon: ููู ุนุจุงุฑุฉ ุนู ูุณุจุฉ ุงูุฎุทุฃ ุงููุณููุญ ุจู
            closed: [True OR False] ูู ุงูุดูู ูุบูู 
    """
    # ุงููุญูุท
    peri = cv2.arcLength(contour, True)
    # ุงูุงุฑูุงู
    corners = cv2.approxPolyDP(contour, 0.02 * peri, True)

    # ?  ูุฐู ุญูุงูุฉ ุงุถุงููุฉ ูู ุญุฏูุซ ุฎุทุง ูู ุชุญุฏูุฏ ุงููุฑูุฉ
    # ?  ูุงูู ูู ุงููุนุฑูู ุงู ุงููุฑู ุนุจุงุฑุฉ ุนู ูุณุชุทูู ูููุง 4 ุฃุฑูุงู
    # ?  ูุฐุง ุงุฐุง ูุฌุฏ ุงูุซุฑ ูู ุฐูู  ูู ููู ูุฐุง ุงูุดูู ูุฑูุฉ
    #! ููููููููููููููููููููููููููููู
    # ? ูู ูุซูุฑ ูู ุงูุฃุญูุงู ุณุชููู ุงููุฑูุฉ ูุซููุฉ
    # ? ููุฐูู ุณูููู ููุง ุงูุซุฑ ูู 4 ุฃุฑูุงู
    # ? ูุฐูู ุณุชุฑุฌุน ูุฐู ุงูุฏุงูุฉ ุฌููุน ุงูููุท ุงููุณุชุฎุฑุฌุฉ
    # ? ููู ุฏุงูุฉ ุงุฎุฑู ุณูุนุงูุฌ ุชูู ุงููุดููุฉ

    # if len(corners) != 4:
    #     return None

    """
        np.squeeze() ูุงุฆุฏุฉ
        
        ! ูุจู 
        [
            [[110  71]]
            [[101 202]]
            [[227 203]]
            [[214  76]]
        ] 
        shape: (4, 1, 2)
        =============================
        ! ุจุนุฏ
        [
            [110  71]
            [101 202]
            [227 203]
            [214  76]
        ]
        shape: (4, 2)
    """

    return np.squeeze(corners)


def order_corner_points_clockwise(points):
    # Initzie ูุงุฆูุฉ ุจุงูุฅุญุฏุงุซูุงุช ุงูุชู ุณูุชู ุทูุจูุง
    # ุจุญูุซ ูููู ุงูุฅุฏุฎุงู ุงูุฃูู ูู ุงููุงุฆูุฉ ุฃุนูู ุงููููู ุ
    # ุงูุฅุฏุฎุงู ุงูุซุงูู ูู ุฃุนูู ุงููููู ุ ูุงูุซุงูุซ ูู
    # ุฃุณูู ุงููููู ุ ูุงูุฑุงุจุน ูู ุฃุณูู ุงููุณุงุฑ
    rect = np.zeros((4, 2), dtype="float32")

    #! ููู ุฌุฏุง
    #! ==========
    # ? numpy array  ุงูุตูุฑุฉ ุนุจุงุฑุฉ ุนู
    # ? ุงูุนููุฏ ุงูุงูู ูู ุงูุดูุงู ูู ููู ุงููุญูุฑ ุงูุฑุฃุณู
    # ? ุงูุนููุฏ ุงูุซุงูู ูู ุงูุดูุงู ูู ููู ุงููุญูุฑ ุงูุฃููู

    # ุณุชุญุชูู ุงูููุทุฉ ุงูุนูููุฉ ุงููุณุฑู ุนูู ุฃุตุบุฑ ุฌูุน ุ ูู ุญูู
    # ุณุชุญุชูู ุงูููุทุฉ ุงูุณูููุฉ ุงููููู ุนูู ุฃูุจุฑ ุฌูุน
    axis_sum = np.sum(points, axis=1)
    rect[0] = points[np.argmin(axis_sum)]
    rect[2] = points[np.argmax(axis_sum)]

    # ุงูุขู ุ ุงุญุณุจ ุงููุฑู ุจูู ุงูููุงุท
    # ุฃุนูู ูููู ุงูููุทุฉ ุณูููู ููุง ุฃุตุบุฑ ูุฑู ุ
    # ุจูููุง ุณูููู ุฃุณูู ุงููุณุงุฑ ุฃูุจุฑ ูุฑู
    axis_diff = np.diff(points, axis=1)
    rect[1] = points[np.argmin(axis_diff)]
    rect[3] = points[np.argmax(axis_diff)]

    # ุงูุงุฑูุงู ุงูุงุฑุจุนุฉ ูุชุฑุชุจุฉ
    return rect


def apply_top_view(image, pts):
    (tl, tr, br, bl) = pts

    # ุญุณุงุจ ุนุฑุถ ุงูุตูุฑุฉ ุงูุฌุฏูุฏุฉ ุงูุชู ุณุชููู
    # ุฃูุตู ูุณุงูุฉ ุจูู ุฃุณูู ุงููููู ูุฃุณูู ุงููุณุงุฑ
    # x-ููุณู ุฃู ุฅุญุฏุงุซูุงุช ุณ ุฃุนูู ูููู ูุฃุนูู ูุณุงุฑ
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))

    # ุญุณุงุจ ุงุฑุชูุงุน ุงูุตูุฑุฉ ุงูุฌุฏูุฏุฉ ุงูุชู ุณุชููู
    # ุฃูุตู ูุณุงูุฉ ุจูู ุฃุนูู ุงููููู ูุฃุณูู ุงููููู
    # ุฅุญุฏุงุซูุงุช ุต ุฃู ุฅุญุฏุงุซูุงุช ุต ุฃุนูู ุงููุณุงุฑ ูุฃุณูู ุงููุณุงุฑ
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))

    # ุงูุขู ูุฏููุง ุฃุจุนุงุฏ ุงูุตูุฑุฉ ุงูุฌุฏูุฏุฉ ุ ูู ุจุงูุจูุงุก
    # ูุฌููุนุฉ ููุงุท ุงููุฌูุฉ ููุญุตูู ุนูู "ููุธุฑ ุนูู ุงูุทููุฑ" ุ
    # (ุฃู ุนุฑุถ ูู ุฃุนูู ูุฃุณูู) ููุตูุฑุฉ ุ ูุชุญุฏูุฏ ุงูููุงุท ูุฑุฉ ุฃุฎุฑู
    # ูู ุฃุนูู ุงููุณุงุฑ ุ ุฃุนูู ุงููููู ุ ูุฃุณูู ุงููููู ุ ูุฃุณูู ุงููุณุงุฑ ุงูุชุฑุชูุจ
    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype="float32")

    # ุญุณุงุจ ูุตูููุฉ ุชุญููู ุงูููุธูุฑ ุซู ุชุทุจููู
    M = cv2.getPerspectiveTransform(pts, dst)
    warped = cv2.warpPerspective(image, M, (maxWidth, maxHeight))

    # ุฅุนุงุฏุฉ ุงูุตูุฑุฉ ุงููุดููุฉ
    return warped


def make_page_upright(src):

    image = None
    if isinstance(src, str):  # ูุณุงุฑ ุงูุตูุฑุฉ ูู ุงููุนุทู ููุฏุงูุฉ
        image = cv2.imread(src)
    else:  # ุงูุตูุฑุฉ ููุณูุง ุงููุนุทู ููุฏุงูุฉ
        image = src

    original_height, original_width = image.shape[:2]
    new_height = 400

    # ? ุฎูู ุงูุทูู 400 ุจูุณู ูุงููููุฉ ุฏู ููุญุชุงุฌูุง ูููุง ุจุนุฏ
    h_ratio = original_height / new_height

    #!==============
    # ? ุงูุฎุทูุฉ ุฑูู 1
    # ? ุนูููุง ุชุตุบูุฑ ููุตูุฑุฉ ุนุดุงู ุชุจูู ุงูุนูููุงุช ุงุณุฑุน + ุนูููุงุช ุฃุณุงุณูุฉ
    #!==============
    small_image = resize(image, height=new_height)

    #! ููู ุฌุฏุง ุนุดุงู ูููู ุชุณุจุจ ุงุฎุทุงุก ููู ูู ุชุทุจู ุชูู ุงูุญุทูุฉ
    w_ratio = original_width / small_image.shape[1]

    gray_small_image = cv2.cvtColor(small_image, cv2.COLOR_BGR2GRAY)
    blurred_gray_small_image = cv2.GaussianBlur(gray_small_image, (9, 9), 0)
    canny_blurred_gray_small_image = cv2.Canny(
        blurred_gray_small_image, 120, 240)

    #!==============
    # ? ุงูุฎุทูุฉ ุฑูู 2
    # ? ุชุญุฏูุฏ ุญุฏูุฏ ุงููุฑูุฉ
    #!==============
    copy = small_image.copy()
    cnts = cv2.findContours(canny_blurred_gray_small_image,
                            cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]

    biggest_contour = sorted(cnts, key=cv2.contourArea, reverse=True)[0]

    #!==============
    # ? ุงูุฎุทูุฉ ุฑูู 3
    # ? ุชุญุฏูุฏ ููุท ุงุฑูุงู ุงููุฑูุฉ
    #!==============
    unordered_corners = get_corner_points(biggest_contour)
    #!  ุฎุทูุฉ ูููุฉ ุฌุฏุง
    corners = order_corner_points_clockwise(unordered_corners)
    #!==============
    # ? ุงูุฎุทูุฉ ุฑูู 4
    # ? ุชุนุฏูู ููุธุฑ ุงููุฑูุฉ
    #!==============
    #! ๐๐๐๐ ุฎุทูุฉ ูููุฉ ุฌุฏุง ๐๐๐๐
    new_corners = np.zeros((4, 2), dtype="float32")
    for i in range(len(corners)):
        new_corners[i] = [corners[i][0] * w_ratio, corners[i][1] * h_ratio]

    return apply_top_view(image, new_corners)


# #!==============
# # ? ุงูุฎุทูุฉ ุฑูู 0
# # ? ูุฑุงุกุฉ ุงูุตูุฑุฉ
# #!==============
# image = cv2.imread("./images/page.jpg")

# original_height, original_width = image.shape[:2]
# new_height = 400
# cv2.imshow("image", image)
# cv2.waitKey(0)

# # ? ุฎูู ุงูุทูู 400 ุจูุณู ูุงููููุฉ ุฏู ููุญุชุงุฌูุง ูููุง ุจุนุฏ
# ratio = original_height / new_height

# #!==============
# # ? ุงูุฎุทูุฉ ุฑูู 1
# # ? ุนูููุง ุชุตุบูุฑ ููุตูุฑุฉ ุนุดุงู ุชุจูู ุงูุนูููุงุช ุงุณุฑุน + ุนูููุงุช ุฃุณุงุณูุฉ
# #!==============
# small_image = resize(image, height=new_height)
# cv2.imshow("image", small_image)
# cv2.waitKey(0)

# gray_small_image = cv2.cvtColor(small_image, cv2.COLOR_BGR2GRAY)
# cv2.imshow("image", gray_small_image)
# cv2.waitKey(0)

# blurred_gray_small_image = cv2.GaussianBlur(gray_small_image, (9, 9), 0)
# cv2.imshow("image", blurred_gray_small_image)
# cv2.waitKey(0)

# canny_blurred_gray_small_image = cv2.Canny(blurred_gray_small_image, 120, 240)
# cv2.imshow("image", canny_blurred_gray_small_image)
# cv2.waitKey(0)

# #!==============
# # ? ุงูุฎุทูุฉ ุฑูู 2
# # ? ุชุญุฏูุฏ ุญุฏูุฏ ุงููุฑูุฉ
# #!==============
# copy = small_image.copy()
# cnts = cv2.findContours(canny_blurred_gray_small_image,
#                         cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[-2]

# biggest_contour = sorted(cnts, key=cv2.contourArea, reverse=True)[0]
# cv2.drawContours(copy, [biggest_contour], -1, (0, 255, 0), 2)
# cv2.imshow("image", copy)
# cv2.waitKey(0)


# #!==============
# # ? ุงูุฎุทูุฉ ุฑูู 3
# # ? ุชุญุฏูุฏ ููุท ุงุฑูุงู ุงููุฑูุฉ
# #!==============
# unordered_corners = get_corner_points(biggest_contour)
# print(len(unordered_corners))
# draw_corners(copy.copy(), unordered_corners)

# #! ุฎุทูุฉ ูููุฉ ุฌุฏุง
# corners = order_corner_points_clockwise(unordered_corners)
# draw_corners(copy, corners)
# #!==============
# # ? ุงูุฎุทูุฉ ุฑูู 4
# # ? ุชุนุฏูู ููุธุฑ ุงููุฑูุฉ
# #!==============
# new_image = apply_top_view(image, np.float32(corners)*ratio)
# cv2.imshow("image", resize(new_image, height=400))
# cv2.waitKey(0)

#!==============
# ? ุงูุฎุทูุฉ ุฑูู 5
# ? ุชุฏุฑูุจุงุช
#!==============
# TODO ุฌุนู ุงูููุงู ุจุงุฑุฒ ุงูุซุฑ
# TODO Trackbars ุงุณุชุฎุฏู
# TODO ุงูุณูุงุญ ูููุณุชุฎุฏู ุจุงุฏุฎุงู ุงูุซุฑ ูู ุตูุฑุฉ ููุจุฑูุงูุฌ
# TODO ุญูุธ ุงูุตูุฑ ูู ูุฌูุฏ
